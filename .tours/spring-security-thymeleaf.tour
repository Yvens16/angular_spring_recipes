{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Spring security thymeleaf",
  "steps": [
    {
      "file": "spring_app/pom.xml",
      "description": "### Spring Security et Thymeleaf\n\nPour le cours qui va suivre, j'ai commencer par ajouter les packages Spring Security et Thymeleaf. En utilisant la méthode que je vous ai montré en les copiant depuis Spring Initializr. \n\nSpring Security est le package qui va nous permettre d'activé certaines sécurité par défaut et d'autres que l'on devra configurer nous même. Mais dites vous bien que Spring Security est un package qui va nous faciliter les tâches d'authentification (se connecter) et d'authorisation (accèder à des ressources protégées).\n\nThymeleaf n'est qu'un simple moteur de template HTML me permettant d'utiliser des données dynamique dans les fichiers html que l'on mettera dans le dossier templates.",
      "line": 42
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/security/SecurityConfig.java",
      "description": "### Security Config\n\nEn créant la classe `SecurityConfig` on va pouvoir définir des méthodes utilisable à travers le context de notre application.\n\n- L'annotation `@Configuration` à la ligne 15, dit à Spring que cette classe est une source de définition de Bean  (Un Bean est un objet qui va être gérer par Spring directement) plutôt que du code lié à l'applicatition. (À Voir un peu plus tard).\n- L'annotation `@EnabledWebSecurity` est celle qui permet d'activer Spring Security dans notre application avec sa configuration par défaut. ",
      "line": 18
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/security/SecurityConfig.java",
      "description": "### Bean (BCryptPasswordEncoder)\n\nVoici un exemple d'objet que l'on va rendre disponible dans le contexte de notre application.\n`BCryptPasswordEncoder` est une classe qui permet de hasher (rendre illisible) notre mot de passe avant de l'enregistrer en base de données.",
      "line": 22
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/security/SecurityConfig.java",
      "description": "## One more Bean (UserDetailsService)\n\n`UserDetailsService` est une interface qui va nous permettre de définir notre source d'utilisateurs.\nElle possède une méthode (`loadUserByUsername`) à implementer nous même. Vous pouvez la voir en faisant un ctrl+click sur la classe `UserDetailsService`.\n\nIci, j'ai utilisé l'annotation `@Override` pour implémenter `loadByUsername` avec la logique qui me convient le mieux pour récupérer un utilisateur. \n\nMême si `loadByUsername` dit prendre un `username` en vérité, elle prend un String en paramètre donc vous pouvez utiliser le champs qui définit le mieux l'unicité de votre utilisateur tant que c'est un String tel qu'une addresse email par exemple.\n\nIci j'ai utilisé `username` pour l'exemple par soucis de simplicité. ",
      "line": 34
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/security/SecurityConfig.java",
      "description": "### Bean SecurityFilterChain\n\nLe dernier mais pas des moindre, le ***SecurityFilterChain*** est un objet qui va nous permettre de définir nos règles de sécuritées.  Attention ouvrez bien les yeux ahah. \n\n- ***authorizeHttpRequests*** nous permet de définir exactement comment nous allons autoriser les requêtes à notre serveur. \n    - Ici, je ne permet qu'au utilisateurs qui ont un role ADMIN OU USER de naviguer sur ses routes la.\n    - Seul un utilisateur avec le role ADMIN peut naviguer sur la route ***/admin***\n    - Et pour finir juste pour l'exemple je dis, que toutes les routes commençant par ***/other*** ne seront atignable que pour les utilisateurs connecté peu importe leur role. c'est un peu comme le  ***hasAnyAuthority*** un peu plus haut du coup. \n- La méthode ***formLogin*** permet simplement d'accepter l'authentification par formulaire. \n- La méthode ***logout*** permet simplement de dire qu'un post sur la route ***/logout*** déconnecte l'utilisateur.\n- Le ***permitAll*** dit simplement que n'importe qui peut accèder à cette route, utilisateur ou simple visiteur. \n\nCe n'est qu'une partie de ce que propose la classe ***HttpSecurity*** je vous conseille de vous rensigner méticuleusement sur la documentation.  ",
      "line": 53,
      "selection": {
        "start": {
          "line": 1,
          "character": 1
        },
        "end": {
          "line": 3,
          "character": 58
        }
      }
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/security/SecurityConfig.java",
      "description": "### UserDetails\n\nAvant de quitter le fichier, vous avez dû remarquer qu'ici l'on renvoyait une méthode ***asUserDetails*** provenant de ***UserEntity***.\n\n***UserDetails*** est une interface fournie par spring security qui représent un utilisateur contenant seulement les info utiles dans le contexte de de l'authentification ou de l'autorisation. Elle permet de séparer les info dont on besoin du superflu de la classe UserEntity comme les voitures que l'utilisateur possède par exemple.",
      "line": 32
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/entity/UserEntity.java",
      "description": "### Contruction de UserDetails\n\nNous y voilà, ici nous contruisons notre objet ***UserDetails**.\n- Tout d'abord, je crée une liste d'autorisations d'après les role que possèdent nos utilisateurs. (Ici il n'y a qu'un rôle par soucis de simplicité, mais il peut y en avoir plusieurs).\n\nPuis je construit mon Userdatails à partir de ***User*** qui est importer depuis (Attention!)\n```java\nimport org.springframework.security.core.userdetails.User;\n```\n\n",
      "line": 104
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/entity/UserEntity.java",
      "description": "### UserEntity\n\nC'est bien pour ça que j'ai changé le nom de la table en ***UserEntity*** et que j'ai préciser de quel table il s'agit grâce à l'annotation ***@Table***\n\nRevenons à nos moutons... ==> ",
      "line": 25
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/entity/UserEntity.java",
      "description": "#### UserDetails (suite)\n\nL'utilisation de Role et et de SimpleGrantedAuthority sont interchangeable. D'ailleurs vous pouvez voir ici que je construit mon tableau d'authorities à partir des roles de l'utilisateurs. \n\nJe lui ajoute un username, son mdp et voilà nous avons notre objet UserDetails à utiliser dans le contexte de sécurité de notre application !",
      "line": 105
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/service/Generator.java",
      "description": "#### Bcrypt à l'oeuvre\n\nComme vous pouvez le voir, ici j'encode le mot de passe de l'utilisateur à la création de l'utilisateur. Vous pouvez regarder en base de données. À quoi ressemble le mdp en base.\nÇa ressemble un String de ce format `$2a$10$R1.O64.w9/u5OcVeZHjDM.hndsKEbl/RRBbfeSGonnSmG4OLnaBga`.",
      "line": 37
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/service/Generator.java",
      "description": "### Testez\n\nVoilà, il ne nous reste plus qu'à tester l'application.\nVous pouvez lancer le projet et naviguer sur la route ***\"/\"*** vous verrez que vous serez rediriger par défaut vers la route ***\"/login\"*** c'est un effet de Spring Security.\n\nIl ne vous reste plus qu'à entrée un username et un mot de passe parmi la liste des users ci-dessus et voir ce que ça fais. \n\nEssayez de naviguer sur la route ***\"/admin\"*** avec un utilisateur qui n'a pas un rôle ***ADMIN*** . Puis connectez vous avec un Admin et réessayer. ",
      "line": 40
    }
  ],
  "ref": "spring_security_spring_only"
}