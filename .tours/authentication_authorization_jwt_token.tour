{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "authentication_authorization_jwt_token",
  "steps": [
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/controller/UserController.java",
      "description": "# Introduction\nDans cette recette nous allons voir comment nous authentifier sur notre serveur spring boot et pouvoir accéder à nos ressources grâce à un Json Web Token.\n\n### Comment se passe l'authentification sur une serveur ?\n\nIl faut savoir que notre serveur ne maintient pas l'état de l'utilisateur quand il est connecté (Stateless). Cela veut dire que l'on va utiliser un méchanisme (JWT). Pour dire à notre serveur qui nous sommes à chaque appel api.\nCe JWT sera générer sur le serveur, envoyer au front et conserver par le front qui l'utilisera à chaque appel API pour confirmer notre identité. (Un peu comme une carte d'identité que vous gardez sur vous en permanence).\n\n### Et le serveur lui\n\nLe serveur se contente d'avoir certaines vérifications pour checker si l'utilisateur qui fais son appel API est bien celui qu'il dit être. Si oui il donne accès aus données requêter sinon il nous rembarre. \n",
      "line": 29
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/controller/UserController.java",
      "description": "# L'utilisateur s'inscrit\n\nÀ l'inscription, l'utilisateur va appeller cette méthode (sur la route ```\"/register\"```) avec les informations qu'il aura rentrer sur son formulaire.\n```java\nprivate String username\nprivate String password\nprivate String email\n```\nNous allons donc créer cette utilisateur et l'enregistrer en base.\n```java\n  userService.register\n```\nAllons jeter un oeil dans la méthode avant de revenir ici.",
      "line": 44
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/service/UserService.java",
      "description": "# Register (Crée un utilisateur)\n\nCette méthode:\n- Vérifie simplement si le mot de passe est assez sécurisé pour pouvoir l'utiliser.\n- Vérifie si l'email n'existe pas déjà pour voir si il n'a pas déjà un compte.\n- Hash le mod de passe our qu'il soit illisible, si un hackeur nous pirate la base de données\n- Lui ajoute un rôle ADMIN ou USER, ici c'est un USER pour l'exemple\n- L'enregistre en base de données pour finir\n\nAllez maintenant que notre utilisateur est enregistrer en base, retournons dans notre controlleur, suivez moi. ",
      "line": 53
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/controller/UserController.java",
      "description": "# GenerateToken (Crée un token JWT)\n[Ici vous pouvez voir la représentation d'un token encodée et décoder](https://jwt.io/)\n\nSuivez moi dans le \n```java\njwtUtilService\n```\nPour voir comment on crée notre token et quel package est utilisé.",
      "line": 45
    },
    {
      "file": "spring_app/pom.xml",
      "description": "# JJWT packages\n\nPour créer et utiliser nos tokens dans de bonnes conditions, nous avons besoin de ces 3 packages. \n- jjwt-api est la package qui nous permet d'utiliser les méthodes pour créer et gérer nos tokens (surtout des interfaces).\n- jjwt-iml nous donne la réelle implémentation des méthodes de jjw-api\n- jjwt-jackson est le package qui permet de faire la conversion de notre Token en String vers un objet JSON et inversement. \n\nGo crée le token ==> ",
      "line": 39
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/jwt/JwtUtil.java",
      "description": "# GenerateToken and createToken\n\nRien de neuf sous le soleil, la méthode pour créer le token est et restera toujours la même. Je l'ai trouvé sur internet.\n- Après avoir ajouté, le role de l'utilisateur à mon objet claims, j'appelle la méthode createToken qui est celle qui va vraiment nous crée le toekn à travers. \n```java \nJwts.builder()\n```\n- La méthode builder instancie la création du token\n- setClaims y ajoute l'objet avec des info qui peuvent nous intéresser comme le Role par exemple\n- setSubject y ajoute l'identité de notre utilisateur (peut être un username ou un email par exemple)\n- setIssuedAt représente la date de création du token. (Toujours maintenant)\n- setExpiration représente dans combien de temps ce token ne sera plus valide. Ici dans 10h en millisecondes (1000 * 60 * 60 * 10).\n- signWith, on signe le token utilisant un algorithme de cryptographie.\n  - On crée une signature avec un mdp secret crée par vous. le mien c'est (SECRETKEYquiEstSuperLongSaGrandJeTeLeDisMoiMonAmi) qui à été encodée en base64.\n  - Cette signature est ajouté au token, il permet donc de vérifié que le token n'a pas été modifié. Parce que si quelqu'un tente de modifier le token. La signature change. \n  - Au moment de la vérification du token, on vérifie aussi la signature donc, si elle ne correspond pas à celle qu'on a crée on sait que le token n'est pas valide car un hackeur à tenté de le modifer?\n- compact() termine la création du token et ous renvoie un string hasher comme vous avez pu le voir sur le site [jwt](https://jwt.io/) à gauche ou il y'a marqué encoded.\n\n\nVoilà les petits potes notre token est crée, je vais prendre un café moi,je vous conseille d'y aller aussi.\nEt après on enchaîne ! \n",
      "line": 45
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/controller/UserController.java",
      "description": "# Renvoyer le token sur le front\n\nUne fois que le token à été générer, on le renvoie sur le front. Coe vous pouvez le voir j'ai mis les infos dans un objet de type Hashmap comme ça j'ai pu y mettre le token et le user. \n\nLa classe Api Response est une simple classe qui permet de renvoyer les donner ou une erreur si une est générer. Vous pouvez cliquer dessus pour voir de quoi elle est composé. \n\nPour faire un test je vous conseille d'utiliser Postman. Il y a une image avec un exemple de chaque image dans le dossier ressources/static.",
      "line": 43
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/controller/UserController.java",
      "description": "# Login\n\nMaintenant on va voir comment est fait le login. La méthode à la même disposition que la regitser mais ici, au lieu de créer un utilisateur on vérifier si il existe et sin son mdp correspond.",
      "line": 60
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/service/UserService.java",
      "description": "# Login (explication)\n\n- On récupère les infos transférer depuis le front pour appeller la méthode \n```java\ngetUserEntityByEmailuser.getEmail()\n```\n\nOn va aller chercher l'utilisateur par son email et le renvoyer si il existe sinon on renvoie une erreur. \n- Ensuite on va vérifier si le mot de passe correspond au mot de passe hasher grâce à Bcrypt.\n  - Ici Bcrypt encode le mdp visible et le compare au mot de passe encoder venant de la base de données.\n- Si tout est bon j'ajoute le rôle du user à UserDto avant de le renvoyer. (Juste pour voir si ça marche bien sinon pas besoin en vrai).",
      "line": 76
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/controller/UserController.java",
      "description": "# Login: pour finir\n\nEnsuite pour finir je crée et j'ajoute un token avant de renvoyer les infos sur le front. \n\n# Ok c'est cool, mais comment protège t'on notre serveur ? \n\nC'est vrai ça, on a vu comment créer le token et le renvoyer sur le front en cas de création de compte ou de login.\nMais, on à pas encore protéger notre serveur ! Bah ouai pour l'instant le token sert à rien si il n'y rien pour vérifier ce dit token. \n\nAllez on enchaîne, j'sépère que ce café était fort ! ",
      "line": 61,
      "selection": {
        "start": {
          "line": 10,
          "character": 1
        },
        "end": {
          "line": 10,
          "character": 54
        }
      }
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/security/SecurityConfig.java",
      "description": "# UserDetails Service\n\nVous vous souvenez de cette méthode qui permet de charger notre utilisateur dans le contexte de sécurité de notre application ? On le fait de cette manière plutôt pour aller vite et faire de petits exemple.\n\nEn créant une classe dédié on va utiliser une méthode plus flexible et plus propice à une application de production. Car on va pouvoir injecter notre classe n'importe ou dans notre serveur et utiliser différents source de données pour récupérer nos utilisateur si besoin.\n\n\nOn va commencer par l'isoler dans son propre fichier, pour voir une autre manière de faire. ",
      "line": 42
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/service/UserDetailsServiceApp.java",
      "description": "# UserDetailsServiceApp\n\nEt la voici grandeur nature.\nElle implémente loadUserByUsername comme avant mais cette fois-ci on va renvoyer un UserPrincipal. Qui est une simple classe qui renvoie un UserDetails comme avant. ",
      "line": 25
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/jwt/UserPrincipal.java",
      "description": "# UserDetails\n\nL'interface UserDetails est une simple interface qui définit quel type de données on devrait charger dans le contexte de sécurité. Vous pouvez voir son code en faisant un ctrl+click dessus à la ligne 13. \n\nOk ça c'est fait, on va pouvoir passer aux choses sérieuses. ",
      "line": 36
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/filters/JwtRequestFilter.java",
      "description": "# Le filtre (Notre videur devant la boîte)\n\nLa classe JwtRequestFilter implémente OncePerRequestFilter qui est une classe qui s'active une fois à chaque requête sur notre serveur. Pratique ça veut dire que notre videur va pouvoir intervenir à chaque requête pour vérifier le TOKEN (carte d'identité) de chaque utilisateur.\n\n\n",
      "line": 23
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/filters/JwtRequestFilter.java",
      "description": "# doFilterInternal\n\nNotre videur à donc une méthode ```doFilterInternal```  qui est un peu sa checklist des choses à faire pour bien vérifier notre token.\nC'est donc cette éthode qui s'active à chaque requête sur notre serveur. ",
      "line": 34
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/filters/JwtRequestFilter.java",
      "description": "# doFilterInternal implémentation\n\nJe vous conseille de suivre les commentaires en lisant le code ce sera plus simple à comprendre, il n'y a pas vraiment de logique ici. C'est la manière de faire dans Spring.\n\nMais dans les grandes lignes:\n- On récupère le token de la requête et on en extrait le username\n- Ensuite on vérifie si le token est valide (signature, expiré ou pas, si le username correspond ou pas)\n- Ensuite charge le user dans le contexte de sécurité avec toutes les infos dont le role.\n\nPuis la méthode chain.doFilter nous fais passer au prochain filtre si il y'en a un ou se termine ici.",
      "line": 74
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/security/SecurityConfig.java",
      "description": "# La liste de filtres\n\nVoici ce dont on parle quand on parle du prochain filtre, voyez dans la classe SecurityConfig, nous avons une liste de filtre qui s'active les uns après les autres.\nEt ici on vient ajouter notre propre filtre que l'on vient de créer jwtRequestFilter. \n\n- UsernamePasswordAuthenticationFilter est une classe par défaut de spring security, elle intercepte les requêtes de connexion. Par défaut celle sur la route /login. Et essaye connecter le user avec ses identifiants\n\n- addFilterBefore veut dire avant de procéder à une authentification par identifiants essaye de voir si il n'y a pas un jwt d'actifs avant ça et donc de le faire par jwt. ",
      "line": 61
    }
  ],
  "ref": "authentication_authorization_spring_postman"
}