{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "one-to-one",
  "steps": [
    {
      "title": "Introduction",
      "description": "Dans ce cours, nous allons voir la relation one-to-one qui se traduit par une clé étrangère du côté de notre choix. Ici nous allons créer 2 tables, User et Address pour l'addresse d'expédition de notre utilisateur. Ce cours ne se déroule que sur la partie Spring boot de ce dépôt git. "
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/entity/Address.java",
      "description": "Nous allons tout d'abord crée notre entité ```Address``` qui représente l'adresse de nos utilisateurs, elle contient plusieurs champs dont une rue (street), une ville (city) et un code postal (zipcode). \n\nElle contient aussi un Id qui est générer automatiquement grâce à la strategy Identity à la ligne 12. ",
      "line": 1
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/entity/Address.java",
      "description": "L'annotation ```@Id``` indique que id est la clé primaire de notre entrée en base de données.",
      "line": 11
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/entity/Address.java",
      "description": "Ici j'ajoute un constructeur avec des paramètre afin de pouvoir directement initialiser un objet de type Address avec des valeurs. \n\nJ'ai ensuite mes getters et mes setters qui vont me permettre de lire et modifier les valeurs de ma classe (street, city, zipcode).",
      "line": 19
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/repository/AddressRepository.java",
      "description": "Après avoir crée mon entité, je dois crée un repository, cette interface va me permettre d'utiliser les méthodes ```CRUD``` de base sur le base de données. (Create, Read, Update, Delete).\n\nJe vais donc pouvoir géréer mes opérations en base de données grâce à elle. \n\nElle prend en paramètre, l'entité concernée ici ```Address``` et le type de la clé primaire de l'entité Address qui est ```Long```. \n\nVous pouvez même y déclarer vos propres requêtes soit par requêtes native (ce que l'on verra un peu plus tard dans une autre recette ou par nom de méthode propre à JPA) ===>",
      "line": 1
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/repository/AddressRepository.java",
      "description": "Voici un exemple de requête custom.\n\n```java\nList<Address> findByCity(String city)\n```\nCette requête va permettre de renvoyer toutes les addresses situé dans la même ville. \n\nVoici une liste de mots clé possible à utiliser: [liste](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords)\n\n",
      "line": 11
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/entity/User.java",
      "description": "Ici nous allons utiliser l'annotation #OneToOne pour créer notre lien entre le User et son Address\n\n```FetchType.LAZY``` est une stratégie qui permet d'augmenter l'efficacité de l'application en réduisant la charge de données requise de la base de données en une seule fois. \n\nIci par exemple avec cette stratégie, l'entité Address ne sera pas chargé tant que l'on aura pas fait appel au getter ```getShippingAddress``` de l'entité User. \n\nFetchType.LAZY : indique que la relation doit être chargée à la demande ;\nFetchType.EAGER : indique que la relation doit être chargée en même temps que l'entité qui la porte.\n\n\n```optional = false``` indique qu'un User doit absolument avoir une addresse.\n\n```CascadeType.PERSIST``` indique que si l'on sauvegarde une entité A qui à une relation de parenté avec une entité B, l'entité B sera aussi sauvegarder sans rien faire. \n\nVous pourrez le voir dans le fichier SpringAppApplication ou le fait de sauvegarder le User sauvegarde automatiqument l'Address dans sa propre table. ",
      "line": 24
    },
    {
      "file": "spring_app/src/main/java/com/yvens_belaston_recipes/spring_app/SpringAppApplication.java",
      "description": "Ici nous utilisant le CoomandLineRunner qui spécifie une méthode qui s'exécute directement après le lancement du serveur Spring Boot.\n\nNous avons crée 2 utilisateur avec chacun un nom propre et une addresse, comme nous l'avons mentionnée plus tôt. À l'enregistrement de l'utilisateur nous sauvegardons aussi automatiquement l'addresse ainsi que le la clé étrangère qui unit l'utilisateur et l'addresse. ",
      "line": 41
    }
  ],
  "ref": "one_to_one_associations_spring_only"
}